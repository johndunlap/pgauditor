#!/bin/bash

# =============================================================================
#                               _ _ _
#   _ __   __ _  __ _ _   _  __| (_) |_ ___  _ __
#  | '_ \ / _` |/ _` | | | |/ _` | | __/ _ \| '__|
#  | |_) | (_| | (_| | |_| | (_| | | || (_) | |
#  | .__/ \__, |\__,_|\__,_|\__,_|_|\__\___/|_|
#  |_|    |___/
#
# =============================================================================
# MIT License
#
# Copyright (C) 2023 John Dunlap<john.david.dunlap@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# =============================================================================
# Set connection parameters by defining the following environment variables:
# https://www.postgresql.org/docs/current/libpq-envars.html
# PGHOST
# PGPORT
# PGDATABASE
# PGUSER
# PGPASSWORD
#
# =============================================================================

# Process command-line options using getopt
OPTIONS="t:a:m:vh"
LONGOPTS="table:,auth:,mode:,version,help"

# Parse the options and store them in variables
PARSED_OPTIONS=$(getopt -n "$0" -o "$OPTIONS" --long "$LONGOPTS" -- "$@")
if [ $? -ne 0 ]; then
    >&2 echo "Failed to parse command line options"
    exit 1
fi
eval set -- "$PARSED_OPTIONS"

# TODO: Automate the setting of this version number
VERSION="1.0"

# These values have been selected as the defaults because they are the most
# common use cases and because they are the easiest for the user to implement
# in their application.
AUTH_TYPE="user"
MODE="all"

# Define help message so that we can use it during validation
HELP=$(cat<<EOF
Usage: $(basename $0) [OPTIONS]
Options:
  -t, --table=TABLE            Specify the table which should be audited. This
                               option is required.
  -a, --auth=[set|user|anon]   The mechanism used to determine the current
                               user. The set authentication type uses the
                               values of a configuration parameter to determine
                               the current user. The advantage of the set
                               authentication type is that it allows a single
                               database user to be shared between multiple
                               application level users without losing track of
                               who modified what. The down side of the set
                               authentication type is that developers are
                               responsible for setting and unsetting the
                               configuration parameter in their application
                               to ensure accurate reporting. The user
                               authentication type captures the current
                               database username. The anon option does not
                               require authentication. The default value is
                               user.
  -m, --mode=[all|changed]     In "all" mode, the full row will be captured in
                               the audit table regardless of how many columns
                               were modified. In "changed" made, only the columns
                               which have changed will be captured in the audit
                               table. The benefits of only capturing values
                               which have changed are that the audit table
                               takes up less space on disk and it is easier
                               to identify what has been changed. The drawback
                               is that it is more difficult to get a complete
                               snapshot of the row when the change occurred if
                               everything in the audit table is null except for
                               the value(s) which changed. The default is "all"
                               mode.
  -v, --version                Print $(basename $0) version and exit
  -h, --help                   Print this help message and exit
EOF
)

# Process the parsed options
while true; do
    case "$1" in
        -t | --table)
            TABLE="$2"
            shift 2
            ;;
        -a | --auth)
            AUTH_TYPE="$2"
            shift 2
            ;;
        -m | --mode)
            MODE="$2"
            shift 2
            ;;
        -v | --version)
            echo "${VERSION}"
            exit 0
            ;;
        -h | --help)
            echo "${HELP}"
            exit 0
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Internal error!"
            exit 1
            ;;
    esac
done

# Check for required parameters
if [ -z "$TABLE" ]; then
    >&2 echo "Table name is required"
    exit 2
fi

# Verify that the table exists in PostgreSQL
psql -c "SELECT 1 FROM ${TABLE} LIMIT 1" > /dev/null 2>&1
if [ $? -ne 0 ]; then
    >&2 echo "Table ${TABLE} does not exist"
    exit 3
fi

# Verify that the auth type is known and supported
if [ "${AUTH_TYPE}" != "set" ] && [ "${AUTH_TYPE}" != "user" ] && [ "${AUTH_TYPE}" != "anon" ]; then
    >&2 echo "Unknown auth type: ${AUTH_TYPE}. Supported auth types are set, user, and anon"
    exit 4
fi

#Verify that the mode is known and supported
if [ "${MODE}" != "all" ] && [ "${MODE}" != "changed" ]; then
    >&2 echo "Unknown mode: ${MODE}. Supported modes are all and changed"
    exit 6
fi

AUDIT_TABLE_NAME="aud_${TABLE}"

# Create a temporary file for storing the column metadata so that we can use it multiple times
COLUMN_TMP_FILE=$(mktemp)

# Register a trap to delete the temporary file on exit
trap 'rm -f "$COLUMN_TMP_FILE"' EXIT

# Cache column names and types in a temporary file
psql -t <<EOF | sed '/^$/d' | sed 's/^ //g' | tr -s ' ' | sed 's/ | /|/g' > "${COLUMN_TMP_FILE}"
SELECT
    column_name,
    data_type
FROM information_schema.columns
WHERE table_name = '${TABLE}'
ORDER BY ordinal_position
EOF

# Create a generic temporary file
TMP_FILE=$(mktemp)

# Register a trap to delete the temporary file on exit
trap 'rm -f "$TMP_FILE"' EXIT

# Script utility functions
delete_trigger_if_exists() {
  local trigger_name="$1"
  local table_name="$2"

  local query="SELECT EXISTS (
      SELECT 1
      FROM pg_trigger
      WHERE tgname = '$trigger_name'
        AND tgrelid = '$table_name'::regclass
  );"

  # Assumes that connection parameters are set in the environment
  local result=$(psql -t -c "$query" | sed 's/[ ]*//g')

  # Only emit the delete if the trigger exists. This avoids annoying warning messages in the output
  if [[ $result == "t" ]]; then
    echo "DROP TRIGGER IF EXISTS ${trigger_name} ON ${TABLE};"
  fi
}

# Create utility functions
cat <<'EOF'
CREATE OR REPLACE FUNCTION get_current_setting(name text) RETURNS TEXT
LANGUAGE plpgsql
AS $BODY$
DECLARE
    value text;
BEGIN
    SELECT INTO value current_setting(NAME);
        RETURN value;
EXCEPTION WHEN OTHERS THEN
    RETURN NULL;
END;
$BODY$ VOLATILE;
EOF

echo

INSERT_TRIGGER_NAME="${AUDIT_TABLE_NAME}_insert_trigger"
UPDATE_TRIGGER_NAME="${AUDIT_TABLE_NAME}_update_trigger"
DELETE_TRIGGER_NAME="${AUDIT_TABLE_NAME}_delete_trigger"

# Delete the triggers if they exist
delete_trigger_if_exists "${INSERT_TRIGGER_NAME}" "${TABLE}"
delete_trigger_if_exists "${UPDATE_TRIGGER_NAME}" "${TABLE}"
delete_trigger_if_exists "${DELETE_TRIGGER_NAME}" "${TABLE}"

# Drop existing trigger definitions if they exist
cat <<EOF
DROP FUNCTION IF EXISTS audit_${TABLE}_changes();
EOF

echo

psql -t <<EOF > "${TMP_FILE}"
  SELECT EXISTS (
      SELECT 1
      FROM pg_sequences
      WHERE sequencename = 'main_audit_seq'
  );
EOF
SEQUENCE_EXISTS=$(cat "${TMP_FILE}" | sed 's/[ \n]*//g')

# Create main audit sequence if it does not already exist
if [ "f" == "${SEQUENCE_EXISTS}" ]; then
  echo "CREATE SEQUENCE IF NOT EXISTS main_audit_seq;"
fi

psql -t <<EOF > "${TMP_FILE}"
SELECT EXISTS (
   SELECT 1
   FROM pg_type
   WHERE typname = 'pgauditor_operation'
   AND typtype = 'e'
);
EOF
ENUM_EXISTS=$(sed 's/[ \n]*//g' < "${TMP_FILE}")

# Create the operation type enum if it does not already exist
if [ "f" == "${ENUM_EXISTS}" ]; then
  echo "CREATE TYPE pgauditor_operation AS ENUM ('INSERT', 'UPDATE', 'DELETE');"
fi

# Determine if the audit table exists in Postgresql by audit table name
psql -c "SELECT 1 FROM ${AUDIT_TABLE_NAME} LIMIT 1" > /dev/null 2>&1
AUDIT_TABLE_EXISTS=$?

if [ ${AUDIT_TABLE_EXISTS} -eq 0 ]; then
  # Add missing columns to existing audit table
  AUDIT_TABLE_COLUMNS=$(mktemp)
  
  # Register a trap to delete the temporary file on exit
  trap 'rm -f "$AUDIT_TABLE_COLUMNS"' EXIT
  
  # Cache column names and types in a temporary file
  psql -t <<EOF | sed '/^$/d' | sed 's/^ //g' | tr -s ' ' | sed 's/ | /|/g' > "${AUDIT_TABLE_COLUMNS}"
  SELECT
      replace(column_name, 'new_', ''),
      data_type
  FROM information_schema.columns
  WHERE table_name = '${AUDIT_TABLE_NAME}'
    AND column_name not like 'old_%'
    AND column_name not in(
      'audit_id',
      'changed_by',
      'changed_at',
      'operation'
    )
  ORDER BY ordinal_position
EOF

  # Add columns to the existing audit table if they do not already exist
  while IFS= read -r line; do
    # Continue to the next row if the column starts with old_
    if [[ "${line}" == old_* ]]; then
      continue
    fi

    grep "${line}" "${AUDIT_TABLE_COLUMNS}"> /dev/null 2>&1
    if [ $? -ne 0 ];then
      echo "${line}" | awk -v AUDIT_TABLE_NAME="${AUDIT_TABLE_NAME}" '
        BEGIN{
          FS="|";
        }{
          print "ALTER TABLE " AUDIT_TABLE_NAME " ADD COLUMN old_" $1 " " $2 ";";
          print "ALTER TABLE " AUDIT_TABLE_NAME " ADD COLUMN new_" $1 " " $2 ";";
        }
      ' | cat
    fi
  done < "${COLUMN_TMP_FILE}"
else
  # Create audit table
cat <<EOF
CREATE TABLE IF NOT EXISTS ${AUDIT_TABLE_NAME}(
  audit_id bigint UNIQUE NOT NULL DEFAULT nextval('main_audit_seq')
  ,operation pgauditor_operation
  ,changed_by text
  ,changed_at timestamp with time zone
EOF
  # Iterate through the columns
  while IFS= read -r line; do
    echo $line | awk '
      BEGIN{
        FS="|";
      }{
        print "  ,old_" $1 " " $2;
        print "  ,new_" $1 " " $2
        }
      '
  done < "${COLUMN_TMP_FILE}"

  echo ");"
  echo
fi

# Create trigger function
cat <<EOF
CREATE OR REPLACE FUNCTION audit_${TABLE}_changes() RETURNS TRIGGER
AS
EOF
cat <<'EOF'
$BODY$
DECLARE
  changed_by_var text := NULL;
  changed_at_var timestamp with time zone := current_timestamp;
  operation_var pgauditor_operation := NULL;
EOF

# Emit variables for both old and new values
while IFS= read -r line; do
  echo $line | awk '
    BEGIN{
      FS="|";
    }{
      print "  old_" $1 "_var " $2 " := NULL;";
      print "  new_" $1 "_var " $2" := NULL;"
      }
    '
done < "${COLUMN_TMP_FILE}"

cat <<EOF
  change_count INT := 0;
BEGIN
  operation_var=TG_OP::pgauditor_operation;

EOF

if [ "set" == "${AUTH_TYPE}" ]; then
  cat <<EOF
    SELECT INTO changed_by_var get_current_setting('pgauditor.current_user');
    IF changed_by_var is null or trim(changed_by_var) = '' THEN
      RAISE EXCEPTION 'Anonymous updates are not permitted for audited table ${TABLE}. To identify the user making the change run: SET [LOCAL] "pgauditor.current_user"=<user>';
    END IF;
EOF
  echo
elif [ "user" == "${AUTH_TYPE}" ]; then
  # We don't need to check if we have a value because current_user will always return a value
  echo "select into changed_by_var current_user;"
  echo
elif [ "anon" != "${AUTH_TYPE}" ]; then
  >&2 echo "Unsupported auth type: ${AUTH_TYPE}"
  exit 5
fi

cat<<EOF
  IF (operation_var = 'UPDATE') THEN
EOF

if [ "all" == "${MODE}" ]; then
  # Capture all columns regardless of whether or not they changed
  while IFS= read -r line; do
    echo $line | awk '
      BEGIN{
        FS="|";
      }{
        old_name="OLD." $1;
        new_name="NEW." $1;

        print "    old_" $1 "_var := OLD." $1 ";";
        print "    new_" $1 "_var := NEW." $1 ";"
      }
    '
  done < "${COLUMN_TMP_FILE}"
  echo "    change_count := change_count + 1;"
elif [ "changed" == "${MODE}" ]; then
  # Capture only the columns which have changed
  while IFS= read -r line; do
    echo $line | awk '
      BEGIN{
        FS="|";
      }{
        old_name="OLD." $1;
        new_name="NEW." $1;

        print "    IF ((" old_name " IS NULL and " new_name " IS NOT NULL) or (" old_name " IS NOT NULL and " new_name " IS NULL) or (" old_name " != " new_name ")) THEN";
        print "      old_" $1 "_var := OLD." $1 ";";
        print "      new_" $1 "_var := NEW." $1 ";"
        print "      change_count := change_count + 1;"
        print "    END IF;"
      }
    '
  done < "${COLUMN_TMP_FILE}"
fi

cat <<EOF
  ELSIF (operation_var = 'INSERT') THEN
EOF

# Iterate through the columns
while IFS= read -r line; do
  echo $line | awk '
    BEGIN{
      FS="|";
    }{
      print "    new_" $1 "_var := NEW." $1 ";"
    }
  '
done < "${COLUMN_TMP_FILE}"

cat <<EOF
    change_count := change_count + 1;
  ELSIF (operation_var = 'DELETE') THEN
EOF

# Iterate through the columns
while IFS= read -r line; do
  echo $line | awk '
    BEGIN{
      FS="|";
    }{
      print "    old_" $1 "_var := OLD." $1 ";"
    }
  '
done < "${COLUMN_TMP_FILE}"

cat <<EOF
    change_count := change_count + 1;
  ELSE
    raise exception 'Unknown operation: %', operation_var;
  END IF;

  IF change_count > 0 THEN
    INSERT INTO ${AUDIT_TABLE_NAME}(
      audit_id
      ,operation
      ,changed_by
      ,changed_at
EOF

# Iterate through the columns
while IFS= read -r line; do
  echo $line | awk '
    BEGIN{
      FS="|";
    }{
      print "      ,old_" $1;
      print "      ,new_" $1;
    }
  '
done < "${COLUMN_TMP_FILE}"

cat <<EOF
    ) values(
      nextval('main_audit_seq')
      ,operation_var
      ,changed_by_var
      ,changed_at_var
EOF

# Iterate through the columns
while IFS= read -r line; do
  echo $line | awk '
    BEGIN{
      FS="|";
    }{
      print "      ,old_" $1 "_var";
      print "      ,new_" $1 "_var";
    }
  '
done < "${COLUMN_TMP_FILE}"

cat <<'EOF'
    );
  END IF;
  RETURN NULL;
END;
$BODY$
LANGUAGE plpgsql VOLATILE;
EOF

# Create trigger definitions
cat <<EOF
CREATE TRIGGER ${INSERT_TRIGGER_NAME} AFTER INSERT ON ${TABLE} FOR EACH ROW EXECUTE PROCEDURE audit_${TABLE}_changes();
CREATE TRIGGER ${UPDATE_TRIGGER_NAME} AFTER UPDATE ON ${TABLE} FOR EACH ROW EXECUTE PROCEDURE audit_${TABLE}_changes();
CREATE TRIGGER ${DELETE_TRIGGER_NAME} AFTER DELETE ON ${TABLE} FOR EACH ROW EXECUTE PROCEDURE audit_${TABLE}_changes();
EOF